Now I'll implement Step 2.2 (Manual Scan ephemeral + dedupe query) and Step 2.3 (Bidirectional awareness).

First, add a method to journalStore to find active trades by symbol and direction:

Edit
/home/user/forex-decision-engine-/forex-decision-engine/src/storage/journalStore.ts
  }


 


  /**


   * Find active (running/pending) trades by symbol and direction


   * Used for dedupe awareness between manual and auto scan


   */


  async findActiveBySymbolDirection(


    symbol: string,


    direction: string,


    statuses: TradeStatus[] = ['running', 'pending']


  ): Promise<TradeJournalEntry[]> {


    if (isDbAvailable()) {


      try {


        const db = getDb();


        const rows = await db


          .selectFrom('journal_entries')


          .selectAll()


          .where('symbol', '=', symbol)


          .where('direction', '=', direction)


          .where('status', 'in', statuses)


          .orderBy('created_at', 'desc')


          .limit(10)


          .execute();


 


        return rows.map(row => this.rowToJournalEntry(row as Record<string, unknown>));


      } catch (error) {


        logger.error('Failed to find active trades from database', { error });


      }


    }


 


    // Fallback to in-memory


    return this.entries.filter(e =>


      e.symbol === symbol &&


      e.direction === direction &&


      statuses.includes(e.status)


    ).sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())


      .slice(0, 10);


  }


 


  /**


   * Calculate P&L for an entry


   */


Now modify the /api/scan endpoint to make Manual Scan ephemeral with dedupe awareness:

Edit
/home/user/forex-decision-engine-/forex-decision-engine/src/server.ts
  try {


    logger.info(`Scanning with strategy: ${strategyId}`, { 


      symbols: sanitizedSymbols.length, 


      paperTrading: isPaperTrading,


    });


    


    const decisions = await scanWithStrategy(sanitizedSymbols, strategyId, userSettings);


    


    // Save trade signals to both signalStore AND detectionStore for unified lifecycle


    for (const decision of decisions) {


      if (decision.grade !== 'no-trade') {


        // Save to signalStore for history


        await signalStore.saveSignal(decision as any);


        


        // Also save to detectionStore for unified trade lifecycle


        // Only bridge high-quality signals (B grade or better) to detection system


        const gradeRank: Record<string, number> = { 'A+': 5, 'A': 4, 'B+': 3, 'B': 2, 'C': 1, 'no-trade': 0 };


        const decisionGrade = decision.grade || 'no-trade';


        const isHighQuality = (gradeRank[decisionGrade] ?? 0) >= 2; // B grade or better


        


        if (isHighQuality && decision.direction && decision.entry) {


          try {


            const enrichedDecision = {


              ...decision,


              grade: decisionGrade,


              strategyId: decision.strategyId || strategyId,


              strategyName: decision.strategyName || strategyId,


              timestamp: decision.timestamp || new Date().toISOString(),


            };


            await detectionService.processAutoScanDecision(enrichedDecision);


          } catch (detectionError) {


            logger.warn(`Failed to create detection for manual scan: ${decision.symbol}`, { error: detectionError });


          }


        }


      }


    }


 


    // Sort by grade (A+ first), then by symbol for grouping


    const gradeOrder: Record<string, number> = { 'A+': 0, 'A': 1, 'B+': 2, 'B': 3, 'C': 4, 'no-trade': 5 };


    decisions.sort((a, b) => {


      const gradeCompare = (gradeOrder[a.grade] ?? 5) - (gradeOrder[b.grade] ?? 5);


      if (gradeCompare !== 0) return gradeCompare;


      return a.symbol.localeCompare(b.symbol);


    });


 


    res.json({


      success: true,


      count: decisions.length,


      trades: decisions.filter(d => d.grade !== 'no-trade').length,


      decisions,


    });


  } catch (error) {


    logger.error('Scan error', { error });


    res.status(500).json({ 


      error: error instanceof Error ? error.message : 'Scan failed' 


    logger.info(`Scanning with strategy: ${strategyId}`, {


      symbols: sanitizedSymbols.length,


      paperTrading: isPaperTrading,


    });


 


    const decisions = await scanWithStrategy(sanitizedSymbols, strategyId, userSettings);


 


    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


    // MANUAL SCAN IS EPHEMERAL - NO PERSISTENCE


    // Only check for existing trades for dedupe awareness (bidirectional)


    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


 


    for (const decision of decisions) {


      if (decision.grade !== 'no-trade' && decision.direction) {


        // Check for existing trade in Journal (running/pending)


        const journalTrades = await journalStore.findActiveBySymbolDirection(


          decision.symbol,


          decision.direction,


          ['running', 'pending']


        );


 


        // Check for existing detection (cooling_down/eligible)


        const existingDetection = await detectionStore.findActiveDetection(


          decision.strategyId || strategyId,


          decision.symbol,


          decision.direction


        );


 


        // Annotate decision with existing trade info for UI warning


        if (journalTrades.length > 0) {


          (decision as any).existingTrade = {


            source: 'journal',


            id: journalTrades[0].id,


            status: journalTrades[0].status,


            entryPrice: journalTrades[0].entryPrice,


          };


        } else if (existingDetection) {


          (decision as any).existingTrade = {


            source: 'detection',


            id: existingDetection.id,


            status: existingDetection.status,


            entryPrice: existingDetection.entry?.price,


          };


        }


      }


    }


 


    // NOTE: Removed persistence to signalStore and detectionStore


    // Manual scan is now ephemeral - only saves to Journal when user clicks "Take Trade"


 


    // Sort by grade (A+ first), then by symbol for grouping


    // Clone array before sorting to avoid mutation


    const sortedDecisions = [...decisions].sort((a, b) => {


      const gradeOrder: Record<string, number> = { 'A+': 0, 'A': 1, 'B+': 2, 'B': 3, 'C': 4, 'no-trade': 5 };


      const gradeCompare = (gradeOrder[a.grade] ?? 5) - (gradeOrder[b.grade] ?? 5);


      if (gradeCompare !== 0) return gradeCompare;


      return a.symbol.localeCompare(b.symbol);


    });


 


    res.json({


      success: true,


      count: sortedDecisions.length,


      trades: sortedDecisions.filter(d => d.grade !== 'no-trade').length,


      decisions: sortedDecisions,


    });


  } catch (error) {


    logger.error('Scan error', { error });


    res.status(500).json({


      error: error instanceof Error ? error.message : 'Scan failed'


  } finally {


    releaseScanLock(lockKey);


  }


Grep
import.*journalStore|import.*detectionStore
Grep
from.*detection
Edit
/home/user/forex-decision-engine-/forex-decision-engine/src/server.ts
import * as detectionService from './services/detectionService.js';


import * as detectionStore from './storage/detectionStore.js';


import { DetectionFilters } from './types/detection.js';


Now update the frontend to show bidirectional awareness warning:

Read
/home/user/forex-decision-engine-/forex-decision-engine/public/js/ui.js
Read 120 lines
Read
/home/user/forex-decision-engine-/forex-decision-engine/public/js/ui.js
Read 60 lines
Edit
/home/user/forex-decision-engine-/forex-decision-engine/public/js/ui.js
    const decisionKey = `${decision.strategyId}:${decision.symbol}`;


    const sentimentId = `sentiment-${decision.strategyId}-${decision.symbol}`.replace(/[^a-zA-Z0-9-]/g, '-');


 


    return `


      <div class="decision-card ${gradeClass} ${staleClass}" data-key="${decisionKey}" data-symbol="${decision.symbol}" data-strategy="${decision.strategyId}" data-grade="${decision.grade}" tabindex="0" role="article" aria-label="${decision.displayName} ${decision.direction || 'no trade'} signal, Grade ${decision.grade}">


        <div class="card-header">


          <div>


            <span class="card-symbol">${decision.displayName}</span>


            <span class="card-grade ${gradeBadgeClass}">${gradeDisplay}</span>


          </div>


          <span class="card-direction ${directionClass}">${directionText}</span>


        </div>


        ${strategyInfo}


        <div class="card-body">


          ${tradeInfoHTML}


          ${noTradeReasonHTML}


          ${warningsHTML}


          ${optimalHTML}


          ${freshnessHTML}


          ${sentimentHTML}


          ${reasonCodesHTML}


          ${!isNoTrade || !noTradeReasonHTML ? `<div class="card-reason">"${decision.reason}"</div>` : ''}


        </div>


        <div class="card-footer">


          <span class="timing ${timingState}">


            ${decision.timeframes?.trend || 'H4'}/${decision.timeframes?.entry || 'H1'} | ${validText}${degradeText ? ` ‚Ä¢ ${degradeText}` : ''}


          </span>


          <div class="card-actions">


            ${!isNoTrade ? `<button class="btn btn-small" onclick="App.copySignal('${decisionKey}')">üìã Copy</button>` : ''}


          </div>


        </div>


        ${!isNoTrade ? `


        <div class="card-journal-actions">


          <button class="btn btn-journal btn-taken" onclick="App.logTrade('${decisionKey}', 'taken')">‚úì Took Trade</button>


    // Existing trade warning for bidirectional awareness


    const existingTrade = decision.existingTrade;


    const hasExistingTrade = !!existingTrade;


    const existingTradeHTML = hasExistingTrade ? `


      <div class="existing-trade-warning">


        <span class="warning-icon">‚ö†Ô∏è</span>


        <span class="warning-text">Trade already ${existingTrade.source === 'journal' ? 'RUNNING' : 'DETECTED'} @ ${existingTrade.entryPrice?.toFixed(5) || 'N/A'}</span>


        <span class="warning-status">(${existingTrade.status})</span>


      </div>


    ` : '';


 


    return `


      <div class="decision-card ${gradeClass} ${staleClass} ${hasExistingTrade ? 'has-existing-trade' : ''}" data-key="${decisionKey}" data-symbol="${decision.symbol}" data-strategy="${decision.strategyId}" data-grade="${decision.grade}" tabindex="0" role="article" aria-label="${decision.displayName} ${decision.direction || 'no trade'} signal, Grade ${decision.grade}">


        <div class="card-header">


          <div>


            <span class="card-symbol">${decision.displayName}</span>


            <span class="card-grade ${gradeBadgeClass}">${gradeDisplay}</span>


          </div>


          <span class="card-direction ${directionClass}">${directionText}</span>


        </div>


        ${strategyInfo}


        ${existingTradeHTML}


        <div class="card-body">


          ${tradeInfoHTML}


          ${noTradeReasonHTML}


          ${warningsHTML}


          ${optimalHTML}


          ${freshnessHTML}


          ${sentimentHTML}


          ${reasonCodesHTML}


          ${!isNoTrade || !noTradeReasonHTML ? `<div class="card-reason">"${decision.reason}"</div>` : ''}


        </div>


        <div class="card-footer">


          <span class="timing ${timingState}">


            ${decision.timeframes?.trend || 'H4'}/${decision.timeframes?.entry || 'H1'} | ${validText}${degradeText ? ` ‚Ä¢ ${degradeText}` : ''}


          </span>


          <div class="card-actions">


            ${!isNoTrade ? `<button class="btn btn-small" onclick="App.copySignal('${decisionKey}')">üìã Copy</button>` : ''}


          </div>


        </div>


        ${!isNoTrade ? `


        <div class="card-journal-actions">


          <button class="btn btn-journal btn-taken ${hasExistingTrade ? 'disabled' : ''}" onclick="App.logTrade('${decisionKey}', 'taken')" ${hasExistingTrade ? 'disabled title="Trade already exists"' : ''}>


            ${hasExistingTrade ? '‚ö†Ô∏è Already Taken' : '‚úì Took Trade'}


          </button>


      </div>


    `;


  },


Also update the signals table view:

Edit
/home/user/forex-decision-engine-/forex-decision-engine/public/js/ui.js
      const rr = d.riskReward ? d.riskReward.toFixed(1) : '-';


      const stratName = d.strategyName || d.strategyId || '-';


      const key = `${d.strategyId || 'default'}:${d.symbol}`;


 


      return `


        <tr data-key="${key}">


          <td class="col-symbol">${d.symbol}</td>


          <td class="col-direction ${dirClass}">${d.direction?.toUpperCase() || '-'}</td>


          <td class="col-grade"><span class="grade-badge ${gradeClass}">${d.grade}</span></td>


          <td class="col-price">${d.entry?.formatted || '-'}</td>


          <td class="col-price">${d.stopLoss?.formatted || '-'}</td>


          <td class="col-price">${tp1}</td>


          <td class="col-price">${tp2}</td>


          <td class="col-numeric">${lots}</td>


          <td class="col-numeric">${rr}</td>


          <td>${stratName}</td>


          <td class="col-actions">


            ${d.grade !== 'no-trade' ? `


              <button class="table-btn primary" onclick="App.takeSignalTrade('${key}')">Take</button>


      const hasExisting = !!d.existingTrade;


      const existingIcon = hasExisting ? '‚ö†Ô∏è ' : '';


 


      return `


        <tr data-key="${key}" class="${hasExisting ? 'has-existing-trade' : ''}">


          <td class="col-symbol">${existingIcon}${d.symbol}</td>


          <td class="col-direction ${dirClass}">${d.direction?.toUpperCase() || '-'}</td>


          <td class="col-grade"><span class="grade-badge ${gradeClass}">${d.grade}</span></td>


          <td class="col-price">${d.entry?.formatted || '-'}</td>


          <td class="col-price">${d.stopLoss?.formatted || '-'}</td>


          <td class="col-price">${tp1}</td>


          <td class="col-price">${tp2}</td>


          <td class="col-numeric">${lots}</td>


          <td class="col-numeric">${rr}</td>


          <td>${stratName}</td>


          <td class="col-actions">


            ${d.grade !== 'no-trade' ? `


              <button class="table-btn primary ${hasExisting ? 'disabled' : ''}" onclick="App.takeSignalTrade('${key}')" ${hasExisting ? 'disabled title="Trade already exists"' : ''}>


                ${hasExisting ? 'Exists' : 'Take'}


              </button>


        </tr>


      `;


    }).join('');


