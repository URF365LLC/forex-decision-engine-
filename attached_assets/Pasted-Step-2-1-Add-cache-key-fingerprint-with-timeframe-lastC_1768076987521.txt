Step 2.1: Add cache key fingerprint with timeframe + lastClosedBarTs

Edit
/home/user/forex-decision-engine-/forex-decision-engine/src/engine/strategyAnalyzer.ts
const logger = createLogger('StrategyAnalyzer');


 


const DECISION_CACHE_TTL = 5 * 60;       // 5 minutes for actionable signals


const NO_TRADE_CACHE_TTL = CACHE_TTL.noTrade;  // 2 minutes for no-trade decisions


 


function makeDecisionCacheKey(symbol: string, strategyId: string): string {


// Reduced TTL - fingerprint handles invalidation via lastClosedBarTs


const DECISION_CACHE_TTL = 60;           // 60 seconds (fingerprint handles staleness)


const NO_TRADE_CACHE_TTL = CACHE_TTL.noTrade;  // 2 minutes for no-trade decisions


 


/**


 * Get the timestamp of the last fully closed bar.


 * Excludes the currently forming candle to prevent stale cache.


 */


function getLastClosedBar(bars: Bar[], timeframe: string): string | null {


  if (!bars || bars.length === 0) return null;


 


  // Get the last bar


  const lastBar = bars[bars.length - 1];


  if (!lastBar.timestamp) return null;


 


  const barTime = new Date(lastBar.timestamp);


  const now = new Date();


 


  // Determine bar duration based on timeframe


  const barDurationMs: Record<string, number> = {


    '1h': 60 * 60 * 1000,


    '4h': 4 * 60 * 60 * 1000,


    '1day': 24 * 60 * 60 * 1000,


    'H1': 60 * 60 * 1000,


    'H4': 4 * 60 * 60 * 1000,


    'D1': 24 * 60 * 60 * 1000,


  };


 


  const duration = barDurationMs[timeframe] || barDurationMs['1h'];


  const barCloseTime = new Date(barTime.getTime() + duration);


 


  // If the bar hasn't closed yet, use the previous bar


  if (barCloseTime > now && bars.length > 1) {


    return bars[bars.length - 2].timestamp;


  }


 


  return lastBar.timestamp;


}


 


/**


 * Create fingerprinted cache key including timeframe and last closed bar timestamp.


 * This ensures cache invalidation when a new bar closes.


 */


function makeDecisionCacheKey(


  symbol: string,


  strategyId: string,


  timeframe?: string,


  lastClosedBarTs?: string


): string {


  if (timeframe && lastClosedBarTs) {


    return `decision:${symbol}:${strategyId}:${timeframe}:${lastClosedBarTs}`;


  }


  // Fallback for legacy calls without fingerprint


function makeNoTradeCacheKey(symbol: string, strategyId: string): string {


  return `no-trade:${symbol}:${strategyId}`;


}


